<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>themisasi.io API documentation</title>
<meta name="description" content="Read THEMIS GBO ASI data" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>themisasi.io</code></h1>
</header>
<section id="section-intro">
<p>Read THEMIS GBO ASI data</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/env python
&#34;&#34;&#34;
Read THEMIS GBO ASI data
&#34;&#34;&#34;
import logging
import warnings
from pathlib import Path
from datetime import datetime, timedelta
import xarray
from typing import Tuple, Sequence, List
import numpy as np
from dateutil.parser import parse
import scipy.io

try:
    import cdflib
    Epoch = cdflib.cdfepoch()
    cdfread = cdflib.cdfread.CDF
except ImportError:
    Epoch = cdfread = None
try:
    import h5py
except ImportError:
    h5py = None
try:
    import netCDF4
except ImportError:
    netCDF4 = None


def load(path: Path,
         site: str = None,
         treq: List[datetime] = None,
         calfn: Path = None) -&gt; xarray.Dataset:
    &#34;&#34;&#34;
    read THEMIS ASI camera data

    If treq is not specified, the whole file is loaded

    Parameters
    ----------
    path: pathlib.Path
        directory where Themis ASI data files are
    site: str, optional
        site code e.g. gako
    treq: datetime.datetime or list of datetime.datetime, optional
        requested time to load
    calfn: pathlib.Path, optional
        path to calibration file (skymap)

    Returns
    -------
    data: xarray.Dataset
        Themis ASI data (image stack)
    &#34;&#34;&#34;
# %% time slice (assumes monotonically increasing time)
    if treq is not None:
        treq = _timereq(treq)

    imgs = _timeslice(path, site, treq)
# %% optional load calibration (az, el)
    data = xarray.Dataset({&#39;imgs&#39;: imgs})
    data.attrs = imgs.attrs

    cal = None
    if calfn:
        cal = loadcal(calfn, site, treq)
    else:
        try:
            cal = loadcal(path, site, treq)
        except FileNotFoundError:
            pass

    if cal is not None:
        if cal.site is not None and cal.site != imgs.site:
            raise ValueError(f&#39;cal site {cal.site} and data site {imgs.site} do not match. Was wrong calibration file used?&#39;)

        data = xarray.merge((data, cal))
        data.attrs = cal.attrs
        data.attrs.update(imgs.attrs)
        if data.caltime is not None:
            if (np.datetime64(data.caltime) &gt;= data.time).any():
                raise ValueError(&#39;calibration is taken AFTER the images--may be incorrect lat/lon az/el plate scale&#39;)

    return data


def filetimes(fn: Path) -&gt; List[datetime]:
    &#34;&#34;&#34;
    prints the times available in a THEMIS ASI CDF file

    Parameters
    ----------
    fn: pathlib.Path
        path to ASI data file

    Returns
    -------
    time: list of datetime.datetime
        times available in this CDF file
    &#34;&#34;&#34;
    if not cdfread:
        raise ImportError(&#39;pip install cdflib&#39;)

    h = cdfread(fn)

    site = h.attget(&#39;Descriptor&#39;, 0)[&#39;Data&#39;][:4].lower()

    return Epoch.to_datetime(h[f&#39;thg_asf_{site}_epoch&#39;][:])


def _timeslice(path: Path,
               site: str = None,
               treq: Sequence[datetime] = None) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    loads time slice of Themis ASI data

    Parameters
    ----------
    path: pathlib.Path
        directory where Themis asi data is
    site: str
        site code e.g. gako for Gakon
    treq: datetime.datetime or list of datetime.datetime
        requested time or min,max time range

    Results
    -------
    data: xarray.DataArray
        Themis ASI data
    &#34;&#34;&#34;
    TIME_TOL = 1  # number of seconds to tolerate in time request offset
# %% open CDF file handle (no close method)
    site, fn = _sitefn(path, site, treq)

    h = cdfread(fn)
# %% load image times
    try:
        time = Epoch.to_datetime(h[f&#39;thg_asf_{site}_epoch&#39;][:], to_np=True)
    except (ValueError, KeyError):
        time = np.array(list(map(datetime.utcfromtimestamp,
                                 h[f&#39;thg_asf_{site}_time&#39;][:])))
# %% time request handling
    if treq is None:
        i = slice(None)
    else:
        atreq = np.atleast_1d(treq)

        if atreq.size == 1:
            # Note: arbitrarily allowing up to 1 second time offset from request
            if all(atreq &lt; (time-timedelta(seconds=TIME_TOL))) | all(atreq &gt; time+timedelta(seconds=TIME_TOL)):
                raise ValueError(f&#39;requested time {atreq} outside {fn}&#39;)

            i = abs(time - atreq[0]).argmin()
        elif atreq.size == 2:  # start, end
            i = (time &gt;= atreq[0]) &amp; (time &lt;= atreq[1])
        else:
            raise ValueError(&#39;for now, time req is single time or time range&#39;)

    imgs = h[f&#39;thg_asf_{site}&#39;][i]
    if imgs.ndim == 2:
        imgs = imgs[None, ...]

    time = time[i]
    if isinstance(time, datetime):
        time = [time]
    elif len(time) == 0:
        raise ValueError(f&#39;no times were found with requested time bounds {treq}&#39;)

    return xarray.DataArray(imgs,
                            coords={&#39;time&#39;: time},
                            dims=[&#39;time&#39;, &#39;y&#39;, &#39;x&#39;],
                            attrs={&#39;filename&#39;: fn.name, &#39;site&#39;: site})


def _sitefn(path: Path,
            site: str = None,
            treq: Sequence[datetime] = None) -&gt; Tuple[str, Path]:
    &#34;&#34;&#34;
    gets site name and CDF key from filename

    Parameters
    ----------
    path: pathlib.Path
        directory or path to THemis ASI data file
    site: str
        site code e.g. gako for Gakona
    treq: datetime.datetime or list of datetime.datetime
        requested time or time range

    Returns
    -------
    site: str
        site code
    fn: pathlib.Path
        path to Themis ASI data file
    &#34;&#34;&#34;

    path = Path(path).expanduser()

    if path.is_dir():
        if not isinstance(site, str):
            raise ValueError(&#39;Must specify filename OR path and site and time&#39;)

        # FIXME: assumes time bounds don&#39;t cross file boundaries
        if treq is None:
            raise ValueError(&#39;Must specify filename OR path and site and time&#39;)
        elif isinstance(treq, datetime):
            t0 = treq
        elif isinstance(treq[0], datetime) and len(treq) in (1, 2):
            t0 = treq[0]
        else:
            raise ValueError(&#39;Must specify filename OR path and site and time&#39;)

        fn = path / f&#39;thg_l1_asf_{site}_{t0.year}{t0.month:02d}{t0.day:02d}{t0.hour:02d}_v01.cdf&#39;
        if not fn.is_file():
            # try to use last time in file, if first time wasn&#39;t covered
            if isinstance(treq, datetime):
                raise FileNotFoundError(fn)

            t0 = treq[-1]

            fn = path / f&#39;thg_l1_asf_{site}_{t0.year}{t0.month:02d}{t0.day:02d}{t0.hour:02d}_v01.cdf&#39;

    elif path.is_file():
        fn = path

        h = cdfread(fn)
        if not site:
            site = h.attget(&#39;Descriptor&#39;, 0)[&#39;Data&#39;][:4].lower()
        if site != h.attget(&#39;Descriptor&#39;, 0)[&#39;Data&#39;][:4].lower():
            raise ValueError(f&#39;{site} is not in {fn}&#39;)
    else:
        raise FileNotFoundError(path)

    return site, fn


def _timereq(treq: List[datetime]) -&gt; List[datetime]:
    &#34;&#34;&#34;
    parse time request
    &#34;&#34;&#34;

    if isinstance(treq, datetime):
        pass
    elif isinstance(treq, str):
        treq = parse(treq)
    elif isinstance(treq[0], str):  # type: ignore
        treq = list(map(parse, treq))  # type: ignore
    elif isinstance(treq[0], datetime):  # type: ignore
        pass
    else:
        raise TypeError(treq)

    return treq


def _downsample(imgs: xarray.Dataset, az: np.ndarray, el: np.ndarray,
                x: np.ndarray, y: np.ndarray) -&gt; xarray.Dataset:
    &#34;&#34;&#34;
    downsamples cal data to match image data

    because of the discontinuous nature of the calibration data, typical resampling is not valid.
    Figured better to add a little error with plain decimation rather than enormous error with invalid technique.
    &#34;&#34;&#34;
    if az.shape == imgs.shape[1:]:
        return az, el, x, y

    downscale = (az.shape[0] // imgs.shape[1],
                 az.shape[1] // imgs.shape[2])

    logging.warning(f&#39;downsizing calibration az/el data by factors of {downscale} to match image data&#39;)

    az = az[::downscale[0], ::downscale[1]]
    el = el[::downscale[0], ::downscale[1]]
    x = np.arange(az.shape[1])
    y = np.arange(az.shape[0])

    return az, el, x, y


def loadcal_file(fn: Path) -&gt; xarray.Dataset:
    &#34;&#34;&#34;
    reads data mapping themis gbo asi pixels to azimuth,elevation
    calibration data url is
    http://data.phys.ucalgary.ca/sort_by_project/THEMIS/asi/skymaps/new_style/

    Parameters
    ----------
    fn: pathlib.Path
        path to calibration file

    Returns
    -------
    cal: xarray.Dataset
        calibration data
    &#34;&#34;&#34;
    site = None
    time = None
    fn = Path(fn).expanduser()
    if not fn.is_file():
        raise FileNotFoundError(fn)

    if fn.suffix == &#39;.cdf&#39;:
        site = fn.name.split(&#39;_&#39;)[3]
        if cdfread is None:
            raise ImportError(&#39;pip install cdflib&#39;)

        h = cdfread(fn)
        az = h[f&#39;thg_asf_{site}_azim&#39;][0]
        el = h[f&#39;thg_asf_{site}_elev&#39;][0]
        lat = h[f&#39;thg_asc_{site}_glat&#39;]
        lon = (h[f&#39;thg_asc_{site}_glon&#39;] + 180) % 360 - 180  # [0,360] -&gt; [-180,180]
        alt_m = h[f&#39;thg_asc_{site}_alti&#39;]
        x = y = h[f&#39;thg_asf_{site}_c256&#39;]
        time = datetime.utcfromtimestamp(h[f&#39;thg_asf_{site}_time&#39;][-1])
    elif fn.suffix == &#39;.sav&#39;:
        site = fn.name.split(&#39;_&#39;)[2]
        # THEMIS SAV calibration files written with glitch from bug in IDL
        warnings.simplefilter(&#34;ignore&#34;, UserWarning)
        h = scipy.io.readsav(fn, python_dict=True, verbose=False)
        warnings.resetwarnings()

        az = h[&#39;skymap&#39;][&#39;full_azimuth&#39;][0]
        el = h[&#39;skymap&#39;][&#39;full_elevation&#39;][0]
        lat = h[&#39;skymap&#39;][&#39;site_map_latitude&#39;].item()
        lon = (h[&#39;skymap&#39;][&#39;site_map_longitude&#39;].item() + 180) % 360 - 180  # [0,360] -&gt; [-180,180]
        alt_m = h[&#39;skymap&#39;][&#39;site_map_altitude&#39;].item()
        x = h[&#39;skymap&#39;][&#39;full_column&#39;][0][0, :]
        y = h[&#39;skymap&#39;][&#39;full_row&#39;][0][:, 0]
        try:
            tstr = h[&#39;skymap&#39;][&#39;generation_info&#39;][0][0][2]
            time = datetime(int(tstr[:4]), int(tstr[4:6]), int(tstr[6:8]), int(tstr[8:10]))
        except (KeyError, ValueError):
            if h[&#39;skymap&#39;][&#39;site_unix_time&#39;] &gt; 0:
                tutc = h[&#39;skymap&#39;][&#39;site_unix_time&#39;]
            elif h[&#39;skymap&#39;][&#39;imager_unix_time&#39;] &gt; 0:
                tutc = h[&#39;skymap&#39;][&#39;imager_unix_time&#39;]
            else:
                tutc = None

            if tutc is not None:
                time = datetime.utcfromtimestamp(tutc)
            else:  # last resort
                time = datetime(int(fn.name[19:23]),
                                int(fn.name[23:25]),
                                int(fn.name[25:27]))

    elif fn.suffix == &#39;.h5&#39;:
        if h5py is None:
            raise ImportError(&#39;pip install h5py&#39;)

        with h5py.File(fn, &#39;r&#39;) as h:
            az = h[&#39;az&#39;][:]
            el = h[&#39;el&#39;][:]
            lat = h[&#39;lla&#39;][0]
            lon = h[&#39;lla&#39;][1]
            alt_m = h[&#39;lla&#39;][2]
            x = h[&#39;x&#39;][0, :]
            y = h[&#39;y&#39;][:, 0]
    elif fn.suffix == &#39;.nc&#39;:
        if netCDF4.Dataset is None:
            raise ImportError(&#39;pip install netCDF4&#39;)

        with netCDF4.Dataset(fn, &#39;r&#39;) as h:
            az = h[&#39;az&#39;][:]
            el = h[&#39;el&#39;][:]
            lat = h[&#39;lla&#39;][0]
            lon = h[&#39;lla&#39;][1]
            alt_m = h[&#39;lla&#39;][2]
            x = h[&#39;x&#39;][0, :].astype(int)
            y = np.flipud(h[&#39;y&#39;][:, 0]).astype(int)
    else:
        raise ValueError(f&#39;{fn} calibration file format is not known to this program.&#39;)

    cal = xarray.Dataset({&#39;az&#39;: ((&#39;y&#39;, &#39;x&#39;), az),
                          &#39;el&#39;: ((&#39;y&#39;, &#39;x&#39;), el)},
                         coords={&#39;y&#39;: y, &#39;x&#39;: x},
                         attrs={&#39;lat&#39;: lat, &#39;lon&#39;: lon, &#39;alt_m&#39;: alt_m,
                                &#39;site&#39;: site, &#39;calfilename&#39;: fn.name,
                                &#39;caltime&#39;: time})

    return cal


def loadcal(path: Path,
            site: str = None,
            time: Sequence[datetime] = None) -&gt; xarray.Dataset:
    &#34;&#34;&#34;
    load calibration skymap file

    Parameters
    ----------
    path: pathlib.Path
        directory or path to calibration file
    site: str
        site code e.g. gako
    time: datetime.datetime or list of datetime.datetime
        time requested

    Returns
    -------
    cal: xarray.Dataset
        calibration data
    &#34;&#34;&#34;
    path = Path(path).expanduser()

    if path.is_file():
        if site is None or time is None:
            try:
                return loadcal_file(path)
            except (KeyError, ValueError):
                return None
        else:
            path = path.parent

    assert isinstance(site, str)
    fn = _findcal(path, site, time)

    return loadcal_file(fn)


def _findcal(path: Path, site: str, time: Sequence[datetime]) -&gt; Path:
    &#34;&#34;&#34;
    attempt to find nearest previous time calibration file
    &#34;&#34;&#34;

    if not path.is_dir():
        raise FileNotFoundError(str(path))

    if not isinstance(site, str) or len(site) != 4:
        raise ValueError(f&#39;site code is four characters e.g. fykn.  You gave:   {site}&#39;)

    if isinstance(time, str):
        time = parse(time)

    if isinstance(time, (list, tuple, np.ndarray)):
        time = time[0]  # assume first time is earliest

    if not isinstance(time, datetime):
        raise TypeError(f&#39;must specify single datetime, you gave:  {time}&#39;)
# %% CDF .cdf
    fcdf = list(path.glob(f&#39;thg_l2_asc_{site}_*.cdf&#39;))
    cdates = [loadcal(fn).caltime for fn in fcdf]

    datecdf = None
    if cdates:
        for i, date in enumerate(cdates):
            if date &lt; time:
                break
        if date &lt; time:
            datecdf = date
            icdf = len(cdates) - (i+1)
# %% IDL .sav
    fsav = list(path.glob(f&#39;themis_skymap_{site}_*.sav&#39;))
    sdates = [loadcal(fn).caltime for fn in fsav]

    datesav = None
    if sdates:
        for i, date in enumerate(sdates):
            if date &lt; time:
                break
        if date &lt; time:
            datesav = date
            isav = len(sdates) - (i+1)

# %% get result
    if not sdates and not cdates:
        raise FileNotFoundError(f&#39;could not find cal file for {site} {time}  in {path}&#39;)
    elif datecdf is None:
        return fsav[isav]
    elif datesav is None:
        return fcdf[icdf]
# tiebreaker
    diff = [abs(datecdf-time), abs(datesav-time)]
    idff = diff.index(min(diff))

    if idff == 0:
        return fcdf[icdf]
    else:
        return fsav[isav]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="themisasi.io.filetimes"><code class="name flex">
<span>def <span class="ident">filetimes</span></span>(<span>fn)</span>
</code></dt>
<dd>
<section class="desc"><p>prints the times available in a THEMIS ASI CDF file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fn</code></strong> :&ensp;<code>pathlib.Path</code></dt>
<dd>path to ASI data file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>list</code> of <code>datetime.datetime</code></dt>
<dd>times available in this CDF file</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def filetimes(fn: Path) -&gt; List[datetime]:
    &#34;&#34;&#34;
    prints the times available in a THEMIS ASI CDF file

    Parameters
    ----------
    fn: pathlib.Path
        path to ASI data file

    Returns
    -------
    time: list of datetime.datetime
        times available in this CDF file
    &#34;&#34;&#34;
    if not cdfread:
        raise ImportError(&#39;pip install cdflib&#39;)

    h = cdfread(fn)

    site = h.attget(&#39;Descriptor&#39;, 0)[&#39;Data&#39;][:4].lower()

    return Epoch.to_datetime(h[f&#39;thg_asf_{site}_epoch&#39;][:])</code></pre>
</details>
</dd>
<dt id="themisasi.io.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>path, site=None, treq=None, calfn=None)</span>
</code></dt>
<dd>
<section class="desc"><p>read THEMIS ASI camera data</p>
<p>If treq is not specified, the whole file is loaded</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>pathlib.Path</code></dt>
<dd>directory where Themis ASI data files are</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>site code e.g. gako</dd>
<dt><strong><code>treq</code></strong> :&ensp;<code>datetime.datetime</code> or <code>list</code> of <code>datetime.datetime</code>, optional</dt>
<dd>requested time to load</dd>
<dt><strong><code>calfn</code></strong> :&ensp;<code>pathlib.Path</code>, optional</dt>
<dd>path to calibration file (skymap)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>xarray.Dataset</code></dt>
<dd>Themis ASI data (image stack)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load(path: Path,
         site: str = None,
         treq: List[datetime] = None,
         calfn: Path = None) -&gt; xarray.Dataset:
    &#34;&#34;&#34;
    read THEMIS ASI camera data

    If treq is not specified, the whole file is loaded

    Parameters
    ----------
    path: pathlib.Path
        directory where Themis ASI data files are
    site: str, optional
        site code e.g. gako
    treq: datetime.datetime or list of datetime.datetime, optional
        requested time to load
    calfn: pathlib.Path, optional
        path to calibration file (skymap)

    Returns
    -------
    data: xarray.Dataset
        Themis ASI data (image stack)
    &#34;&#34;&#34;
# %% time slice (assumes monotonically increasing time)
    if treq is not None:
        treq = _timereq(treq)

    imgs = _timeslice(path, site, treq)
# %% optional load calibration (az, el)
    data = xarray.Dataset({&#39;imgs&#39;: imgs})
    data.attrs = imgs.attrs

    cal = None
    if calfn:
        cal = loadcal(calfn, site, treq)
    else:
        try:
            cal = loadcal(path, site, treq)
        except FileNotFoundError:
            pass

    if cal is not None:
        if cal.site is not None and cal.site != imgs.site:
            raise ValueError(f&#39;cal site {cal.site} and data site {imgs.site} do not match. Was wrong calibration file used?&#39;)

        data = xarray.merge((data, cal))
        data.attrs = cal.attrs
        data.attrs.update(imgs.attrs)
        if data.caltime is not None:
            if (np.datetime64(data.caltime) &gt;= data.time).any():
                raise ValueError(&#39;calibration is taken AFTER the images--may be incorrect lat/lon az/el plate scale&#39;)

    return data</code></pre>
</details>
</dd>
<dt id="themisasi.io.loadcal"><code class="name flex">
<span>def <span class="ident">loadcal</span></span>(<span>path, site=None, time=None)</span>
</code></dt>
<dd>
<section class="desc"><p>load calibration skymap file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>pathlib.Path</code></dt>
<dd>directory or path to calibration file</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>str</code></dt>
<dd>site code e.g. gako</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>datetime.datetime</code> or <code>list</code> of <code>datetime.datetime</code></dt>
<dd>time requested</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cal</code></strong> :&ensp;<code>xarray.Dataset</code></dt>
<dd>calibration data</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loadcal(path: Path,
            site: str = None,
            time: Sequence[datetime] = None) -&gt; xarray.Dataset:
    &#34;&#34;&#34;
    load calibration skymap file

    Parameters
    ----------
    path: pathlib.Path
        directory or path to calibration file
    site: str
        site code e.g. gako
    time: datetime.datetime or list of datetime.datetime
        time requested

    Returns
    -------
    cal: xarray.Dataset
        calibration data
    &#34;&#34;&#34;
    path = Path(path).expanduser()

    if path.is_file():
        if site is None or time is None:
            try:
                return loadcal_file(path)
            except (KeyError, ValueError):
                return None
        else:
            path = path.parent

    assert isinstance(site, str)
    fn = _findcal(path, site, time)

    return loadcal_file(fn)</code></pre>
</details>
</dd>
<dt id="themisasi.io.loadcal_file"><code class="name flex">
<span>def <span class="ident">loadcal_file</span></span>(<span>fn)</span>
</code></dt>
<dd>
<section class="desc"><p>reads data mapping themis gbo asi pixels to azimuth,elevation
calibration data url is
<a href="http://data.phys.ucalgary.ca/sort_by_project/THEMIS/asi/skymaps/new_style/">http://data.phys.ucalgary.ca/sort_by_project/THEMIS/asi/skymaps/new_style/</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fn</code></strong> :&ensp;<code>pathlib.Path</code></dt>
<dd>path to calibration file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cal</code></strong> :&ensp;<code>xarray.Dataset</code></dt>
<dd>calibration data</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loadcal_file(fn: Path) -&gt; xarray.Dataset:
    &#34;&#34;&#34;
    reads data mapping themis gbo asi pixels to azimuth,elevation
    calibration data url is
    http://data.phys.ucalgary.ca/sort_by_project/THEMIS/asi/skymaps/new_style/

    Parameters
    ----------
    fn: pathlib.Path
        path to calibration file

    Returns
    -------
    cal: xarray.Dataset
        calibration data
    &#34;&#34;&#34;
    site = None
    time = None
    fn = Path(fn).expanduser()
    if not fn.is_file():
        raise FileNotFoundError(fn)

    if fn.suffix == &#39;.cdf&#39;:
        site = fn.name.split(&#39;_&#39;)[3]
        if cdfread is None:
            raise ImportError(&#39;pip install cdflib&#39;)

        h = cdfread(fn)
        az = h[f&#39;thg_asf_{site}_azim&#39;][0]
        el = h[f&#39;thg_asf_{site}_elev&#39;][0]
        lat = h[f&#39;thg_asc_{site}_glat&#39;]
        lon = (h[f&#39;thg_asc_{site}_glon&#39;] + 180) % 360 - 180  # [0,360] -&gt; [-180,180]
        alt_m = h[f&#39;thg_asc_{site}_alti&#39;]
        x = y = h[f&#39;thg_asf_{site}_c256&#39;]
        time = datetime.utcfromtimestamp(h[f&#39;thg_asf_{site}_time&#39;][-1])
    elif fn.suffix == &#39;.sav&#39;:
        site = fn.name.split(&#39;_&#39;)[2]
        # THEMIS SAV calibration files written with glitch from bug in IDL
        warnings.simplefilter(&#34;ignore&#34;, UserWarning)
        h = scipy.io.readsav(fn, python_dict=True, verbose=False)
        warnings.resetwarnings()

        az = h[&#39;skymap&#39;][&#39;full_azimuth&#39;][0]
        el = h[&#39;skymap&#39;][&#39;full_elevation&#39;][0]
        lat = h[&#39;skymap&#39;][&#39;site_map_latitude&#39;].item()
        lon = (h[&#39;skymap&#39;][&#39;site_map_longitude&#39;].item() + 180) % 360 - 180  # [0,360] -&gt; [-180,180]
        alt_m = h[&#39;skymap&#39;][&#39;site_map_altitude&#39;].item()
        x = h[&#39;skymap&#39;][&#39;full_column&#39;][0][0, :]
        y = h[&#39;skymap&#39;][&#39;full_row&#39;][0][:, 0]
        try:
            tstr = h[&#39;skymap&#39;][&#39;generation_info&#39;][0][0][2]
            time = datetime(int(tstr[:4]), int(tstr[4:6]), int(tstr[6:8]), int(tstr[8:10]))
        except (KeyError, ValueError):
            if h[&#39;skymap&#39;][&#39;site_unix_time&#39;] &gt; 0:
                tutc = h[&#39;skymap&#39;][&#39;site_unix_time&#39;]
            elif h[&#39;skymap&#39;][&#39;imager_unix_time&#39;] &gt; 0:
                tutc = h[&#39;skymap&#39;][&#39;imager_unix_time&#39;]
            else:
                tutc = None

            if tutc is not None:
                time = datetime.utcfromtimestamp(tutc)
            else:  # last resort
                time = datetime(int(fn.name[19:23]),
                                int(fn.name[23:25]),
                                int(fn.name[25:27]))

    elif fn.suffix == &#39;.h5&#39;:
        if h5py is None:
            raise ImportError(&#39;pip install h5py&#39;)

        with h5py.File(fn, &#39;r&#39;) as h:
            az = h[&#39;az&#39;][:]
            el = h[&#39;el&#39;][:]
            lat = h[&#39;lla&#39;][0]
            lon = h[&#39;lla&#39;][1]
            alt_m = h[&#39;lla&#39;][2]
            x = h[&#39;x&#39;][0, :]
            y = h[&#39;y&#39;][:, 0]
    elif fn.suffix == &#39;.nc&#39;:
        if netCDF4.Dataset is None:
            raise ImportError(&#39;pip install netCDF4&#39;)

        with netCDF4.Dataset(fn, &#39;r&#39;) as h:
            az = h[&#39;az&#39;][:]
            el = h[&#39;el&#39;][:]
            lat = h[&#39;lla&#39;][0]
            lon = h[&#39;lla&#39;][1]
            alt_m = h[&#39;lla&#39;][2]
            x = h[&#39;x&#39;][0, :].astype(int)
            y = np.flipud(h[&#39;y&#39;][:, 0]).astype(int)
    else:
        raise ValueError(f&#39;{fn} calibration file format is not known to this program.&#39;)

    cal = xarray.Dataset({&#39;az&#39;: ((&#39;y&#39;, &#39;x&#39;), az),
                          &#39;el&#39;: ((&#39;y&#39;, &#39;x&#39;), el)},
                         coords={&#39;y&#39;: y, &#39;x&#39;: x},
                         attrs={&#39;lat&#39;: lat, &#39;lon&#39;: lon, &#39;alt_m&#39;: alt_m,
                                &#39;site&#39;: site, &#39;calfilename&#39;: fn.name,
                                &#39;caltime&#39;: time})

    return cal</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="themisasi" href="index.html">themisasi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="themisasi.io.filetimes" href="#themisasi.io.filetimes">filetimes</a></code></li>
<li><code><a title="themisasi.io.load" href="#themisasi.io.load">load</a></code></li>
<li><code><a title="themisasi.io.loadcal" href="#themisasi.io.loadcal">loadcal</a></code></li>
<li><code><a title="themisasi.io.loadcal_file" href="#themisasi.io.loadcal_file">loadcal_file</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>